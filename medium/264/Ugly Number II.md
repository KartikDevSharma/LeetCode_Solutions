
### Intuition

When I first approached this problem, my initial thoughts led me to consider using sets. The idea was to generate ugly numbers and store them in a set, which would automatically handle sorting and deduplication. This seemed like a straightforward solution, but I quickly realized it might not be the most efficient for larger values of n.

Next, I thought of using a min-heap. This approach would allow me to efficiently retrieve the smallest ugly number at each step and generate new candidates. While this method improved upon the set-based approach, I felt there might be an even more optimal solution.

Finally, I had a click about using dynamic programming (DP). The key insight was that each new ugly number must be generated from a previous ugly number multiplied by either 2, 3, or 5. This realization led me to devise a DP approach that would be more efficient than both the set and heap methods.

# Approach

This dynamic programming approach is based on the fundamental property of ugly numbers: every ugly number can be expressed as a product of smaller ugly numbers and the prime factors 2, 3, and 5. Here's a detailed explanation of the approach:

**1. Initialization:**
   - Create an array `uglyNumbers` of size n to store the sequence of ugly numbers.
   - Set the first element `uglyNumbers[0]` to 1, as 1 is the smallest ugly number.

**2. Multiple Pointers:**
   - Initialize three pointers: `index2`, `index3`, and `index5`, all set to 0.
   - These pointers keep track of which previous ugly number we should multiply by 2, 3, and 5 respectively.

**3. Next Candidate Tracking:**
   - Initialize three variables: `next2`, `next3`, and `next5`.
   - Set `next2 = uglyNumbers[index2] * 2`
   - Set `next3 = uglyNumbers[index3] * 3`
   - Set `next5 = uglyNumbers[index5] * 5`
   - These variables represent the next potential ugly number generated by multiplying the current ugly number at each index by its respective prime factor.

**4. Main Loop:**
   - Iterate from i = 1 to n-1 (since we've already set the first ugly number):
     a. Find the next ugly number:
        - Set `nextUgly = min(next2, next3, next5)`
        - This ensures we always choose the smallest candidate as the next ugly number.
     
     b. Add to sequence:
        - Set `uglyNumbers[i] = nextUgly`
     
     c. Update pointers and next candidates:
        - If `nextUgly == next2`:
          - Increment `index2`
          - Update `next2 = uglyNumbers[index2] * 2`
        - If `nextUgly == next3`:
          - Increment `index3`
          - Update `next3 = uglyNumbers[index3] * 3`
        - If `nextUgly == next5`:
          - Increment `index5`
          - Update `next5 = uglyNumbers[index5] * 5`
        - Note: We use "if" instead of "else if" because there might be cases where the next ugly number is generated by multiple prime factors (e.g., 6 is generated by both 2 and 3).

**5. Result:**
   - After the loop completes, `uglyNumbers[n-1]` contains the nth ugly number.
   - Return this value as the final result.

Pseudo-code for this approach:

```
function nthUglyNumber(n):
    uglyNumbers = new array of size n
    uglyNumbers[0] = 1
    
    index2, index3, index5 = 0, 0, 0
    next2, next3, next5 = 2, 3, 5
    
    for i from 1 to n-1:
        nextUgly = min(next2, next3, next5)
        uglyNumbers[i] = nextUgly
        
        if nextUgly == next2:
            index2++
            next2 = uglyNumbers[index2] * 2
        if nextUgly == next3:
            index3++
            next3 = uglyNumbers[index3] * 3
        if nextUgly == next5:
            index5++
            next5 = uglyNumbers[index5] * 5
    
    return uglyNumbers[n-1]
```

This approach generates ugly numbers in ascending order. By maintaining separate pointers for each prime factor, we ensure that we don't miss any ugly numbers and that we generate them in the correct order.

The key to understanding this approach is to visualize it as three separate sequences merging into one:

1. A sequence of ugly numbers multiplied by 2
2. A sequence of ugly numbers multiplied by 3
3. A sequence of ugly numbers multiplied by 5

At each step, we choose the smallest number from these three sequences and add it to our main sequence of ugly numbers. The pointers (index2, index3, index5) keep track of where we are in each of these sub-sequences.

This method is particularly efficient because:

1. We only generate ugly numbers, avoiding any unnecessary calculations or checks.
2. We maintain the sorted order of ugly numbers without explicitly sorting them.
3. We avoid generating duplicate ugly numbers by incrementing the appropriate pointer(s) each time we select a number.

We're essentially building the sequence of ugly numbers incrementally, using previously computed ugly numbers to generate new ones. This aligns perfectly with the principle of dynamic programming, where we solve subproblems and use their solutions to build up to the final solution.

### Complexity

- **Time complexity: $O(n)$**
  
  The time complexity of this approach is O(n). We perform a single pass through a loop that runs n times, and within each iteration, we perform a constant number of operations (comparisons and arithmetic). The min() operation among three numbers is also considered a constant time operation. Therefore, the overall time complexity is linear with respect to n.

- **Space complexity: $O(n)$**
  
  The space complexity is also O(n). We use an array `uglyNumbers` of size n to store all the ugly numbers up to the nth one. Apart from this array, we only use a constant amount of extra space for our pointers and temporary variables, which doesn't affect the overall space complexity.



# Code
```Java []
class Solution {
    public int nthUglyNumber(int n) {
        int[] uglySequence = new int[n];
        uglySequence[0] = 1;
        
        int index2 = 0, index3 = 0, index5 = 0;
        int next2 = 2, next3 = 3, next5 = 5;
        
        for (int i = 1; i < n; i++) {
            int nextUgly = Math.min(next2, Math.min(next3, next5));
            uglySequence[i] = nextUgly;
            
            if (nextUgly == next2) {
                index2++;
                next2 = uglySequence[index2] * 2;
            }
            if (nextUgly == next3) {
                index3++;
                next3 = uglySequence[index3] * 3;
            }
            if (nextUgly == next5) {
                index5++;
                next5 = uglySequence[index5] * 5;
            }
        }
        
        return uglySequence[n - 1];
    }
}
```
```C++ []
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> uglySequence(n);
        uglySequence[0] = 1;
        
        int index2 = 0, index3 = 0, index5 = 0;
        int next2 = 2, next3 = 3, next5 = 5;
        
        for (int i = 1; i < n; i++) {
            int nextUgly = min({next2, next3, next5});
            uglySequence[i] = nextUgly;
            
            if (nextUgly == next2) {
                index2++;
                next2 = uglySequence[index2] * 2;
            }
            if (nextUgly == next3) {
                index3++;
                next3 = uglySequence[index3] * 3;
            }
            if (nextUgly == next5) {
                index5++;
                next5 = uglySequence[index5] * 5;
            }
        }
        
        return uglySequence[n - 1];
    }
};
```
```Python []
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ugly_sequence = [1]
        index2, index3, index5 = 0, 0, 0
        next2, next3, next5 = 2, 3, 5
        
        for _ in range(1, n):
            next_ugly = min(next2, next3, next5)
            ugly_sequence.append(next_ugly)
            
            if next_ugly == next2:
                index2 += 1
                next2 = ugly_sequence[index2] * 2
            if next_ugly == next3:
                index3 += 1
                next3 = ugly_sequence[index3] * 3
            if next_ugly == next5:
                index5 += 1
                next5 = ugly_sequence[index5] * 5
        
        return ugly_sequence[-1]




#Ignore this
def main():
    input = sys.stdin.read().strip()

    test_cases = input.splitlines()
    results = []
    for case in test_cases:
        grid = json.loads(case)
        results.append(Solution().nthUglyNumber(grid))

    with open('user.out', 'w') as f:
        for result in results:
            f.write(f"{result}\n")

if __name__ == "__main__":
    main()
    exit(0)

```
```Go []
func nthUglyNumber(n int) int {
    uglySequence := make([]int, n)
    uglySequence[0] = 1
    
    index2, index3, index5 := 0, 0, 0
    next2, next3, next5 := 2, 3, 5
    
    for i := 1; i < n; i++ {
        nextUgly := min(next2, min(next3, next5))
        uglySequence[i] = nextUgly
        
        if nextUgly == next2 {
            index2++
            next2 = uglySequence[index2] * 2
        }
        if nextUgly == next3 {
            index3++
            next3 = uglySequence[index3] * 3
        }
        if nextUgly == next5 {
            index5++
            next5 = uglySequence[index5] * 5
        }
    }
    
    return uglySequence[n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```
```Rust []
impl Solution {
    pub fn nth_ugly_number(n: i32) -> i32 {
        let mut ugly_sequence = vec![1];
        let (mut index2, mut index3, mut index5) = (0, 0, 0);
        let (mut next2, mut next3, mut next5) = (2, 3, 5);
        
        for _ in 1..n {
            let next_ugly = next2.min(next3).min(next5);
            ugly_sequence.push(next_ugly);
            
            if next_ugly == next2 {
                index2 += 1;
                next2 = ugly_sequence[index2] * 2;
            }
            if next_ugly == next3 {
                index3 += 1;
                next3 = ugly_sequence[index3] * 3;
            }
            if next_ugly == next5 {
                index5 += 1;
                next5 = ugly_sequence[index5] * 5;
            }
        }
        
        *ugly_sequence.last().unwrap()
    }
}
```
```JavaScript []
/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
    const uglySequence = [1];
    let index2 = 0, index3 = 0, index5 = 0;
    let next2 = 2, next3 = 3, next5 = 5;
    
    for (let i = 1; i < n; i++) {
        const nextUgly = Math.min(next2, next3, next5);
        uglySequence.push(nextUgly);
        
        if (nextUgly === next2) {
            index2++;
            next2 = uglySequence[index2] * 2;
        }
        if (nextUgly === next3) {
            index3++;
            next3 = uglySequence[index3] * 3;
        }
        if (nextUgly === next5) {
            index5++;
            next5 = uglySequence[index5] * 5;
        }
    }
    
    return uglySequence[n - 1];
};
```

---
### Example 1: Input `n = 10`

We need to generate the first 10 ugly numbers, and the output should be the 10th ugly number in the sequence.

#### Step-by-Step Dry Run:

| Iteration | Ugly Numbers Array                    | index2 | index3 | index5 | next2 | next3 | next5 | Chosen `nextUgly` | Action                              |
|-----------|---------------------------------------|--------|--------|--------|-------|-------|-------|-------------------|-------------------------------------|
| Init      | [1]                                   | 0      | 0      | 0      | 2     | 3     | 5     | -                 | Initialization                      |
| 1         | [1, 2]                                | 1      | 0      | 0      | 4     | 3     | 5     | 2                 | Increment `index2`, update `next2`  |
| 2         | [1, 2, 3]                             | 1      | 1      | 0      | 4     | 6     | 5     | 3                 | Increment `index3`, update `next3`  |
| 3         | [1, 2, 3, 4]                          | 2      | 1      | 0      | 6     | 6     | 5     | 4                 | Increment `index2`, update `next2`  |
| 4         | [1, 2, 3, 4, 5]                       | 2      | 1      | 1      | 6     | 6     | 10    | 5                 | Increment `index5`, update `next5`  |
| 5         | [1, 2, 3, 4, 5, 6]                    | 3      | 2      | 1      | 8     | 9     | 10    | 6                 | Increment both `index2` and `index3`|
| 6         | [1, 2, 3, 4, 5, 6, 8]                 | 4      | 2      | 1      | 10    | 9     | 10    | 8                 | Increment `index2`, update `next2`  |
| 7         | [1, 2, 3, 4, 5, 6, 8, 9]              | 4      | 3      | 1      | 10    | 12    | 10    | 9                 | Increment `index3`, update `next3`  |
| 8         | [1, 2, 3, 4, 5, 6, 8, 9, 10]          | 5      | 3      | 2      | 12    | 12    | 15    | 10                | Increment both `index2` and `index5`|
| 9         | [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]      | 6      | 4      | 2      | 16    | 15    | 15    | 12                | Increment both `index2` and `index3`|

**Output: 12**

- **Explanation:** After iterating 9 times, the array `uglyNumbers` becomes `[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]`, and the 10th ugly number is `12`, which is our final answer.

### Example 2: Input `n = 1`

We only need to find the first ugly number.

#### Step-by-Step Dry Run:

| Iteration | Ugly Numbers Array                    | index2 | index3 | index5 | next2 | next3 | next5 | Chosen `nextUgly` | Action                              |
|-----------|---------------------------------------|--------|--------|--------|-------|-------|-------|-------------------|-------------------------------------|
| Init      | [1]                                   | 0      | 0      | 0      | 2     | 3     | 5     | -                 | Initialization                      |

**Output: 1**

- **Explanation:** Since `n = 1`, we don't enter the loop, and the first ugly number is simply `1`, which is the base case.

